name: Push to Second Remote

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual triggering

jobs:
  push-to-remote:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags
      
      - name: Configure Git
        run: |
          git config user.name "${{ secrets.GIT_USER_NAME || 'GitHub Actions' }}"
          git config user.email "${{ secrets.GIT_USER_EMAIL }}"
      
      - name: Push to second remote
        env:
          GIT_PAT: "${{ secrets.GIT_PAT }}"
          SECOND_REMOTE_URL: "${{ secrets.SECOND_REMOTE_URL }}"
        run: |
          set -e  # Exit on error
          
          # Debug: Check URL format (without exposing full value)
          URL_LENGTH=${#SECOND_REMOTE_URL}
          echo "SECOND_REMOTE_URL length: ${URL_LENGTH} characters"
          echo "SECOND_REMOTE_URL starts with: ${SECOND_REMOTE_URL:0:20}..."
          
          # Extract repo path from URL using multiple methods
          REPO_PATH=""
          
          # Method 1: Handle https://github.com/username/repo.git format
          if [[ "$SECOND_REMOTE_URL" =~ https://github\.com/([^/]+/[^/]+) ]]; then
            REPO_PATH="${BASH_REMATCH[1]}"
            echo "Matched https:// format"
          # Method 2: Handle git@github.com:username/repo.git format
          elif [[ "$SECOND_REMOTE_URL" =~ git@github\.com:([^/]+/[^/]+) ]]; then
            REPO_PATH="${BASH_REMATCH[1]}"
            echo "Matched git@ format"
          # Method 3: Handle github.com/username/repo.git format (without protocol)
          elif [[ "$SECOND_REMOTE_URL" =~ github\.com[:/]([^/]+/[^/]+) ]]; then
            REPO_PATH="${BASH_REMATCH[1]}"
            echo "Matched github.com format"
          # Method 4: If URL is just username/repo format
          elif [[ "$SECOND_REMOTE_URL" =~ ^[^/]+/[^/]+ ]]; then
            REPO_PATH="$SECOND_REMOTE_URL"
            echo "Matched direct username/repo format"
          fi
          
          # Remove .git suffix if present
          REPO_PATH="${REPO_PATH%.git}"
          
          if [ -z "$REPO_PATH" ]; then
            echo "Error: Could not parse SECOND_REMOTE_URL"
            echo "URL format check failed. Please ensure SECOND_REMOTE_URL is one of:"
            echo "  - https://github.com/username/repo"
            echo "  - git@github.com:username/repo"
            echo "  - username/repo"
            exit 1
          fi
          
          # Validate REPO_PATH format (should be username/repo, no special characters)
          if [[ ! "$REPO_PATH" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
            echo "Error: Invalid repository path format detected"
            echo "Extracted path contains invalid characters or format"
            echo "Path length: ${#REPO_PATH}"
            echo "Please ensure SECOND_REMOTE_URL contains a valid GitHub repository path"
            exit 1
          fi
          
          echo "Repository path extracted: ${REPO_PATH}"
          
          # Validate REPO_PATH is correct format
          if [[ ! "$REPO_PATH" =~ ^[^/]+/[^/]+$ ]]; then
            echo "Error: Invalid repository path format: '${REPO_PATH}'"
            echo "Expected format: username/repository"
            echo "Please check your SECOND_REMOTE_URL secret"
            exit 1
          fi
          
          # Validate PAT is not empty
          if [ -z "$GIT_PAT" ]; then
            echo "Error: GIT_PAT secret is empty or not set"
            exit 1
          fi
          
          # Verify PAT doesn't contain characters that would break URL
          if echo "$GIT_PAT" | grep -qE '[[:space:]]|"|'"'"'|`'; then
            echo "Warning: PAT may contain characters that could break URL"
          fi
          
          # Test PAT validity by making an API call
          echo "Validating PAT..."
          PAT_TEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${GIT_PAT}" "https://api.github.com/user")
          if [ "$PAT_TEST" != "200" ]; then
            echo "Warning: PAT validation returned HTTP ${PAT_TEST}"
            echo "This might indicate the PAT is invalid or lacks permissions"
          else
            echo "PAT validation successful"
          fi
          
          # Construct authenticated URL with PAT embedded
          # For GitHub, we can use the PAT directly as the username
          # Format: https://TOKEN@github.com/owner/repo.git
          AUTH_URL="https://${GIT_PAT}@github.com/${REPO_PATH}.git"
          
          # Verify the URL components are correct
          echo "Repository path: ${REPO_PATH}"
          echo "URL structure: https://***@github.com/${REPO_PATH}.git"
          
          # Add or update remote with authenticated URL
          if git remote | grep -q "^second-remote$"; then
            echo "Updating existing second-remote"
            git remote set-url second-remote "$AUTH_URL"
          else
            echo "Adding new second-remote"
            git remote add second-remote "$AUTH_URL"
          fi
          
          # Verify the remote was set correctly by checking the path
          VERIFY_URL=$(git remote get-url second-remote)
          echo "Verifying remote URL..."
          
          # Test if we can parse the URL back
          if echo "$VERIFY_URL" | grep -q "github.com"; then
            EXTRACTED_PATH=$(echo "$VERIFY_URL" | sed -E 's|https://[^@]+@github.com/([^/]+/[^/]+)\.git|\1|')
            if [ "$EXTRACTED_PATH" = "$REPO_PATH" ]; then
              echo "✓ Remote URL verified - path matches: ${REPO_PATH}"
            else
              echo "✗ Path mismatch!"
              echo "  Expected: ${REPO_PATH}"
              echo "  Got: ${EXTRACTED_PATH}"
              echo "  Full URL (masked): $(echo "$VERIFY_URL" | sed 's/:[^@]*@/:***@/g')"
            fi
          else
            echo "✗ Remote URL doesn't contain github.com"
            echo "  URL (masked): $(echo "$VERIFY_URL" | sed 's/:[^@]*@/:***@/g')"
          fi
          
          # Also test the URL format with curl to see if it's accessible
          echo "Testing URL accessibility..."
          TEST_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -u "${GIT_PAT}:x-oauth-basic" "https://api.github.com/repos/${REPO_PATH}")
          if [ "$TEST_RESPONSE" = "200" ]; then
            echo "✓ URL format is correct and accessible"
          else
            echo "✗ URL test returned: ${TEST_RESPONSE}"
          fi
          
          # Test repository access via API first
          echo "Testing repository access via API..."
          REPO_ACCESS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${GIT_PAT}" "https://api.github.com/repos/${REPO_PATH}")
          if [ "$REPO_ACCESS" != "200" ]; then
            echo "API test returned HTTP ${REPO_ACCESS}"
            if [ "$REPO_ACCESS" = "404" ]; then
              echo "Repository not found or PAT doesn't have access to: ${REPO_PATH}"
            elif [ "$REPO_ACCESS" = "401" ]; then
              echo "Authentication failed - PAT may be invalid or expired"
            else
              echo "Unexpected error accessing repository"
            fi
            echo ""
            echo "Please verify:"
            echo "  1. Repository exists: https://github.com/${REPO_PATH}"
            echo "  2. PAT has 'repo' scope and access to this repository"
            exit 1
          else
            echo "API access test successful - repository is accessible"
          fi
          
          # Check if repository is empty (no default branch)
          echo "Checking if repository is empty..."
          REPO_INFO=$(curl -s -H "Authorization: token ${GIT_PAT}" "https://api.github.com/repos/${REPO_PATH}")
          DEFAULT_BRANCH=$(echo "$REPO_INFO" | grep -o '"default_branch":"[^"]*"' | cut -d'"' -f4 || echo "")
          
          if [ -z "$DEFAULT_BRANCH" ]; then
            echo "Repository appears to be empty (no default branch)"
            echo "Will push with upstream flag to create the branch"
            IS_EMPTY=true
          else
            echo "Repository has default branch: ${DEFAULT_BRANCH}"
            IS_EMPTY=false
          fi
          
          # Test the remote connection (skip if empty repo)
          if [ "$IS_EMPTY" = "false" ]; then
            echo "Testing git remote connection..."
            set +e  # Temporarily disable exit on error to capture output
            CONNECTION_OUTPUT=$(git ls-remote second-remote HEAD 2>&1)
            CONNECTION_EXIT=$?
            set -e  # Re-enable exit on error
            
            if [ $CONNECTION_EXIT -ne 0 ]; then
              echo "Git error output:"
              echo "$CONNECTION_OUTPUT"
              echo ""
              echo "Warning: Could not access remote via git, but will attempt push anyway"
            else
              echo "Git connection test successful!"
            fi
          else
            echo "Skipping git connection test (empty repository)"
          fi
          
          # Push to second remote
          echo "Pushing to second remote: ${REPO_PATH}"
          
          if [ "$IS_EMPTY" = "true" ]; then
            # For empty repos, use -u flag to set upstream and create the branch
            echo "Pushing to empty repository with upstream flag..."
            git push -u second-remote main || {
              echo "Initial push failed, trying with force..."
              git push -u second-remote main --force
            }
            echo "Push successful! Branch 'main' created on remote."
          else
            # For non-empty repos, try normal push first
            set +e  # Temporarily disable exit on error
            PUSH_OUTPUT=$(git push second-remote main 2>&1)
            PUSH_EXIT=$?
            set -e  # Re-enable exit on error
            
            if [ $PUSH_EXIT -ne 0 ]; then
              echo "Push output:"
              echo "$PUSH_OUTPUT"
              echo ""
              
              # Check if it's because the remote branch doesn't exist
              if echo "$PUSH_OUTPUT" | grep -q "no upstream branch"; then
                echo "Remote branch doesn't exist. Setting upstream and pushing..."
                git push -u second-remote main
              elif echo "$PUSH_OUTPUT" | grep -q "rejected"; then
                echo "Push was rejected. Attempting with force..."
                git push second-remote main --force
              else
                echo "Push failed with error. See output above."
                exit 1
              fi
            else
              echo "Push successful!"
            fi
          fi
