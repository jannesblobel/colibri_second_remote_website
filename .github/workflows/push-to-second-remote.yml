name: Push to Second Remote

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allows manual triggering

jobs:
  push-to-remote:
    # Skip this workflow if running in the second remote repository
    # This prevents the workflow from running when it gets pushed to the second remote
    if: github.repository != 'jannesblobel/second_remote_Colibri'
    
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags
          persist-credentials: false # Don't persist credentials to avoid conflicts
      
      - name: Configure Git
        run: |
          git config user.name "${{ secrets.GIT_USER_NAME || 'GitHub Actions' }}"
          git config user.email "${{ secrets.GIT_USER_EMAIL }}"
      
      - name: Push to second remote
        env:
          GIT_PAT: "${{ secrets.GIT_PAT }}"
          SECOND_REMOTE_URL: "${{ secrets.SECOND_REMOTE_URL }}"
        run: |
          set -e
          
          # Extract repository path from URL
          REPO_PATH=""
          if [[ "$SECOND_REMOTE_URL" =~ https://github\.com/([^/]+/[^/]+) ]]; then
            REPO_PATH="${BASH_REMATCH[1]}"
          elif [[ "$SECOND_REMOTE_URL" =~ git@github\.com:([^/]+/[^/]+) ]]; then
            REPO_PATH="${BASH_REMATCH[1]}"
          elif [[ "$SECOND_REMOTE_URL" =~ github\.com[:/]([^/]+/[^/]+) ]]; then
            REPO_PATH="${BASH_REMATCH[1]}"
          elif [[ "$SECOND_REMOTE_URL" =~ ^[^/]+/[^/]+ ]]; then
            REPO_PATH="$SECOND_REMOTE_URL"
          fi
          
          REPO_PATH="${REPO_PATH%.git}"
          
          if [ -z "$REPO_PATH" ] || [[ ! "$REPO_PATH" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
            echo "Error: Could not parse SECOND_REMOTE_URL. Expected format: username/repo or https://github.com/username/repo"
            exit 1
          fi
          
          if [ -z "$GIT_PAT" ]; then
            echo "Error: GIT_PAT secret is not set"
            exit 1
          fi
          
          # Clear existing credential helpers to prevent using github-actions[bot] credentials
          git config --global --unset-all credential.helper || true
          git config --local --unset-all credential.helper || true
          git credential-cache exit 2>/dev/null || true
          
          # Set up authentication: askpass script and credential helper
          echo "#!/bin/bash" > /tmp/git-askpass.sh
          echo "echo '${GIT_PAT}'" >> /tmp/git-askpass.sh
          chmod +x /tmp/git-askpass.sh
          export GIT_ASKPASS=/tmp/git-askpass.sh
          export GIT_TERMINAL_PROMPT=0
          
          git config --global credential.https://github.com.helper store
          echo "https://${GIT_PAT}@github.com" > ~/.git-credentials
          chmod 600 ~/.git-credentials
          
          # Configure remote with PAT in URL
          git remote remove second-remote 2>/dev/null || true
          git remote add second-remote "https://${GIT_PAT}@github.com/${REPO_PATH}.git"
          
          # Verify repository access
          REPO_ACCESS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${GIT_PAT}" "https://api.github.com/repos/${REPO_PATH}")
          if [ "$REPO_ACCESS" != "200" ]; then
            echo "Error: Cannot access repository ${REPO_PATH} (HTTP ${REPO_ACCESS})"
            echo "Please verify the repository exists and the PAT has access"
            exit 1
          fi
          
          # Check if repository is empty
          REPO_INFO=$(curl -s -H "Authorization: token ${GIT_PAT}" "https://api.github.com/repos/${REPO_PATH}")
          DEFAULT_BRANCH=$(echo "$REPO_INFO" | grep -o '"default_branch":"[^"]*"' | cut -d'"' -f4 || echo "")
          [ -z "$DEFAULT_BRANCH" ] && IS_EMPTY=true || IS_EMPTY=false
          
          # Push to second remote
          if [ "$IS_EMPTY" = "true" ]; then
            git push -u second-remote main
          else
            git push second-remote main || git push -u second-remote main
          fi
          
          echo "Successfully pushed to ${REPO_PATH}"
